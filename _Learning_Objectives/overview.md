---
title: 10.020 DDW Learning Objectives
permalink: /lo/weekly
key: lo-weekly
layout: article
nav_key: Learning Objectives
license: false
aside:
  toc: true
show_edit_on_github: false
show_date: false
---

## Week 1: Python

- Apply Python's **procedural** programming and **basic** data structures
- **Define** and **call** functions
- Implement:
  - Bubble sort and
  - Insertion sort algorithms to **sort** a sequence of number
- Use **print** statements to debug code

## Week 2: Analysing Programs

- Write functions to do **binary heap** data structure operation
- Implement **heapsort** using iteration
- Define **Big-O** notation and other asymptotic notations
- Derive **complexity** of a code using its computation model
- Create **plots** from array data for **visualising** computational time
- **Measure** computation time for bubble sort, insertion sort, built-in sort, and heapsort

## Week 3: Divide and Conquer

- Solve problems using **recursion**
- Identify problems that has recursive solutions
- Explain and implement **merge sort** algorithm
- Derive solution of **recurrence** of merge sort using recursion-tree method
- Measure computation time of merge sort and **compare** it with the other sort algorithms

## Week 4: Object-Oriented Paradigm

- Create `class` definitions with initialization and other methods
- Create **stored** property and **computed** property
- Draw UML class diagram of a class with attributes and methods
- Explain `has-a` relationship
- Discuss object **aliasing** and **copying**
- Draw UML class diagram for `has-a` relationship
- Implement abstract data type for **Stack**, **Queue** using Object Oriented paradigm
- **Apply** Stack and Queue for some applications
- Implement Queue using double **Stack** and discuss implementation **impact** on computation time

## Week 5: Searching Data

- Use **Dictionary** to represent graph
- Apply **basic** dictionary operations
- Define **graph**, **vertices**, **edges** and **weights**
- Differentiate **directed** and **undirected** graphs
- Define **paths**
- Create a `Vertex` class and a Graph class
- Represent graphs using **adjacency-list** representation or **adjacency-matrix** representation
- Explain and implement **breadth** first search
- Explain and implement **depth** first search

## Week 6: Inheritance and Object-Oriented Design

- Inherit a class to create a **child** class
- Explain `is-a` relationship
- Draw **UML** diagram for `is-a` relationship
- **Overload** operators to extend class methods
- Implement **Deque** data structure as a subclass of **Queue**
- Implement **Array** and **Linked List** data structure from the same base class

## Week 8: Visualizing and Processing Data

- Create **scatter** plot and statistical plots like box plot, histogram, and bar plot
- Create a **Panda's DataFrame** and selecting data from DataFrame
- Using library to read `CSV` or `EXCEL` file
- **Split** data randomly into training set and testing set
- **Normalize** data using min-max normalization
- Give example of **linear regression and classification**

## Week 9: Modelling Continuous Data

- Write **objective** function of linear regression
- Implement **Gradient Descent algorithm** for optimisation
- Train **linear regression model** using gradient descent
- Transform data for **higher** order features
- Evaluate linear regression model using `r^2` and mean-squared-error
- Evaluate and choose **learning rate**
- Plot **cost** function over iteration time
- Plot **linear** regression

## Week 10: Classifying Categorical Data

- Write objective function of **logistic** regression
- Use logistic regression to **calculate** probabilities of binary classification
- Train logistic **regression** model
- Split data into **training**, **validation**, and **testing** set
- Visualize **non-linear** decision boundary
- Classify **multi-class** problems using one-vs-all technique
- Calculate **confusion** **matrix**, **precision**, and **recall**

## Week 12: Design of State Machines

- Define a **state machine**
- Implement an **Abstract Base Class** for State Machine using abc module
- Define **output** function and **next** state function
- Draw **state transition diagram** and **time-step table**
- **Implement** output function and next state function inside `get_next_values` overridden method.
- **Apply** breadth first search to perform state-space search
